Cross Browser Testing
**********************

Cross Browser Testing is a type of testing to verify if an application works across different browsers as expected and degrades gracefully. It is the process of verifying your application’s compatibility with different browsers.

Why Is It Performed?
For that matter, why is any kind of testing done?
•	To know what is wrong and be able to fix it.
•	To enhance efficiency and user experience and thereby, business.
•	To be informed of any possible pitfalls

Selenium
Selenium is well known for automated testing of the web-based applications. Just by changing the browser to be used for running the test cases, selenium makes it very easy to run the same test cases multiple times using different browsers.
What to Test?

1.	Base Functionality: Links, dialogs, menus etc.
2.	GUI: Graphical User Interface: Look and feel of the application.
3.	Response: How well the application responds to user actions.
4.	Performance: Loading of the pages within allowed the time frame.

**********************

Difference between isDisplayed(), isEnabled() and isSelected() Methods in Selenium WebDriver: 
•	isDisplayed() is the method used to verify the presence of a web element within the web page. The method returns a “true” value if the specified web element is present on the web page and a “false” value if the web element is not present on the webpage. 
•	2. isDisplayed() is capable to check for the presence of all kinds of web elements available. 
•	3. isEnabled() is the method used to verify if the web element is enabled or disabled within the web page. 
•	4. isEnabled() is primarily used with buttons. 
•	5. isSelected() is the method used to verify if the web element is selected or not. 
•	6. isSelected() method is predominantly used with radio buttons, dropdowns and checkboxes.

**********************

How to handle dynamic WebTable In Selenium 
There are two ways of handling WebTable: 
Method – 1: 
• Iterate row and column and get the cell value. 
• Using for loop 
• Get total rows and iterate table 
• Put if(string matches) then select the respective checkbox 
• Lengthy method 


Method – 2:
 • Using custom XPath 
• Using parent and preceding-sibling tags 
• No need to write for loop 
• No full iteration of table 
• Single line statement 
• More dynamic 
• Efficient and fast

**********************

Page Object Model
•	Page Object Model is a design pattern
•	To create Object Repository for web UI elements. 
•	For each web page in the application there should be corresponding page class this Page class will find the WebElements of that web page and also contains Page action methods which perform operations on those WebElements.


Advantages of POM:
1.	Page Object Pattern makes our code cleaner, easy to understand maintainable and reusable.
2.	Object repository is independent of test cases.
3.	Easy integration of POM with TestNG 
4.	Code becomes less and optimized because of the r
5.	We can reusable page methods in the POM classes.


Page Factory
•	PageFactory is an inbuilt Page Object Model concept for Selenium WebDriver.
•	PageFactory separates of Page Object Repository and Test Methods.
•	PageFactory class, we use annotations @FindBy to find WebElement. We use initElements method to initialize web elements 


Explain initElements (driver, assetcataddlocators.class) method of pagefactory ?
Note: Here's what happens: 
When you call initElements, the PageObjectFactory scans your PageObject for fields of the type WebElement. For each WebElement field that your page object has, It creates a proxy object, that proxy object stores the locator of the WebElement (the value of the @FindBy annotation). 
The proxy is then assigned to the field. Later, when your code actually accesses the field, instead of a WebElement object, you retrieve the proxy. Remember that the proxy object "knows" the locator of the WebElement it represents. Now the proxy actually tries to locate that locator on the current page, and returns the actual WebElement if it was found.

Explain PageFactory ?
Example: AssetLocators category = PageFactory.initElements(driver, AssetLocators.class);

Gives:
< AssetLocators > AssetLocators obj= PageFactory.initElements(WebDriver driver, Class< AssetLocators > pageClassToProxy)

•	Instantiate an instance of the given class and set a lazy proxy for each of the WebElement and List<WebElement> fields that have been declared assuming that the field name is also the HTML element's "id" or "name". 
•	This means that for the class: [Class< AssetLocators > pageClassToProxy] public class Page { private WebElement submit; } there will be an element that can be located using the xpath expression "//*[@id='submit']" or "//*[@name='submit']" By default, the element or the list is looked up each and every time a method is called upon it. To change this behaviour, simply annotate the field with the CacheLookup. 
•	To change how the element is located use the FindBy annotation. This method will attempt to instantiate the class given to it, preferably using a constructor which takes a WebDriver instance as its only argument or falling back on a no-arg constructor. An exception will be thrown if the class cannot be instantiated. 

Type Parameters: 
<T> Class of the PageObject 
Parameters: 
driver The driver that will be used to look up the elements 
pageClassToProxy A class which will be initialised. 
Returns: 
An instantiated instance of the class with WebElement and List<WebElement> fields proxied 


Page Factory annotation:
1.	@FindBy 
2.	@CacheLookup

1.	Explain @FindBy  annotation? (org.openqa.selenium.support.FindBy)

•	Used to mark a field on a Page Object to indicate an alternative mechanism for locating the WebElement or a list of WebElements.
•	Used in conjunction with org.openqa.selenium.support.PageFactory this allows users to quickly and easily create PageObjects. 
•	You can either use this annotation by specifying both "how" and "using" or by specifying one of the location strategies (e.g.: "id") with an appropriate value to use. Both options will delegate down to the matching org.openqa.selenium.By methods in By class. For example, these two annotations point to the same element: 
@FindBy (id = "foobar") WebElement foobar;
@FindBy (how = How.ID, using = "foobar") WebElement foobar;

And these two annotations point to the same list of elements: 
@FindBy (tagName = "a") List<WebElement> links;
 @FindBy (how = How.TAG_NAME, using = "a") List<WebElement> links;

Explain CacheLookup annotation?( org.openqa.selenium.support.CacheLookup)
Marker annotation to be applied to WebElements to indicate that it never changes (that is, that the same instance in the DOM will always be used)


**********************

Retry failed test cases Automation 

There are multiple reasons why the test fails. 

 * Due to the network issue. 
 * Due to application down time. 
 * Due to loading issue and etc. 
 * Random browser issues or browser becoming unresponsive 
 * Random machine issues 
 * Server issues like unexpected delay in the response from server
 

Let’s see how we can use it, there are two ways to include retry analyser in your tests
1.	By specifying retryAnalyzer value in the @Test annotation by IRetryAnalyzer Interface
2.	By adding Retry analyser during run time by implementing on the of the Listener interfaces (Listener) using IAnnotationTransformer interfaces

1.	Retry failed test cases Automation using IRetryAnalyzer

package com.qa.retryFailedTCUsingIRetryAnalyzer;

import org.testng.IRetryAnalyzer;
import org.testng.ITestResult;

public class RetryUsingIRetryAnalyzer implements IRetryAnalyzer {
	static int minRetryCount=1;
	static int maxRetryCount=5;
	@Override
	public boolean retry(ITestResult result) {
		// TODO Auto-generated method stub
		if (minRetryCount<=maxRetryCount) {
			System.out.println("Following test case failing VERIFIED: "+result.getName());
			System.out.println("Retry test count : "+(minRetryCount+1));
			minRetryCount++;
			return true;
		}
		return false;
	}
}

import org.testng.Assert;
import org.testng.annotations.Test;
import org.testng.asserts.SoftAssert;

public class TestCaseRetryByIRetryAnalyzer {
	public static SoftAssert softAssert;
	@Test(priority = 0, retryAnalyzer = RetryUsingIRetryAnalyzer.class)
	public void test() {
		softAssert = new SoftAssert();
		System.out.println("test() started.");
		Assert.assertEquals(10, 11);
		System.out.println("test() completed.");
		softAssert.assertAll();
	}

}



2.	Retry failed test cases Automation using Listener interfaces (IAnnotationTransformer)


package com.qa.retryFailedTCUsingIRetryAnalyzer;

import org.testng.IRetryAnalyzer;
import org.testng.ITestResult;

public class RetryUsingIRetryAnalyzer implements IRetryAnalyzer {

	static int minRetryCount=1;
	static int maxRetryCount=5;
	@Override
	public boolean retry(ITestResult result) {
		// TODO Auto-generated method stub
	
		if (minRetryCount<=maxRetryCount) {
			System.out.println("Following test case failing VERIFIED: "+result.getName());
			System.out.println("Retry test count : "+(minRetryCount+1));
			minRetryCount++;
			return true;
		}
		return false;
	}

}



package com.qa.retryFailedTCUsingListener;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import org.testng.IAnnotationTransformer;
import org.testng.annotations.ITestAnnotation;

import com.qa.retryFailedTCUsingIRetryAnalyzer.RetryUsingIRetryAnalyzer;

public class AnnotationTransformer implements IAnnotationTransformer{

	@Override
	public void transform(ITestAnnotation annotation, Class testClass, Constructor testConstructor, Method testMethod) {
		// TODO Auto-generated method stub
		annotation.setRetryAnalyzer(RetryUsingIRetryAnalyzer.class);
	}

}



<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd">
<suite name="Suite" parallel="tests" thread-count="2">
<listeners>
<listener class-name="com.qa.retryFailedTCUsingListener.AnnotationTransformer"> </listener>
</listeners>

<test name="RetryMulitple">	
<classes>
		<class name="com.qa.retryFailedTCUsingListener.TestCaseRetryByListerner" />
	</classes>
</test>





package com.qa.retryFailedTCUsingListener;

import org.testng.Assert;
import org.testng.annotations.Test;

public class TestCaseRetryByListerner {

	@Test
	public void Test1ByListerner() { // retried  6 time 
		System.out.println("Test1ByListerner() started.");
		Assert.assertEquals(false, true);
	}

	@Test
	public void Test2ByListerner() { // retried  6 time
		System.out.println("Test2ByListerner() started.");
		Assert.assertEquals(false, true);
	}
}


**********************

Pro/Advantage
1. Selenium is Open source; which is purely available in the form of API
2. Supports multiple programming language java, python, php, perl, ruby, javascript
3. Its platform independent supports multiple OS windows, mac, linus, unix
4. Cross browser testing chrome, firefox, opera, IE and Safari.
5. Headless browser phantom js, HTMLUnitDriver, chrome headless
6. Easily integrated with open source tools TestNG, cucumber, Jbehave, BDD framework
7. Light weight because available in API form
8. Easily integrated with CI tool Jenkins and build generation Maven 
9. Can be executed on local as well as cloud/vm/server
10. Customize web driver codebase source code will be shared 
11. Wrappers: lot of third party tools can be used with it Appium (mobile application), Protrctor(Angular application), Watir, Robot (python). 

Cons/disadvantage
1. Open source- so there is no direct support.
2. No barcode/captch reading cannot be automated.
3. Need to learn programming – no script less or codeless facility
4. No desktop application automation or windows based application only web based browser automation. 
5. No reports for test result.
6. For any extra work: TC design, build generation, report generation, CI need to use third party tools selenium dose not supports on its own.


**********************

Selenium is a suite of tools. It consists of Selenium IDE, Selenium RC, Selenium Web driver, and Selenium Grid
1.	Selenium IDE:
Selenium IDE (Integrated Development Environment) is a Firefox plug-in. It is the simplest framework in the Selenium Suite. It allows us to record and playback the scripts. Even though we can create scripts using Selenium IDE, we need to use Selenium RC or Selenium WebDriver to write more advanced and robust test cases.

2.	Selenium RC:
Selenium RC/Selenium 1. Selenium RC was the main Selenium project for a long time before the WebDriver merge brought up Selenium 2. Selenium 1 is still actively supported (in maintenance mode). It relies on JavaScript for automation. It supports Java, JavaScript, Ruby, PHP, Python, Perl and C# . It supports almost every browser out there.
Note: Selenium RC is officially deprecated.
3.	Selenium WebDriver:
Selenium WebDriver is a browser automation framework that accepts commands and sends them to a browser. It is implemented through a browser-specific driver. It controls the browser by directly communicating with it. Selenium WebDriver supports Java, C#, PHP, Python, Perl, Ruby.
Operation System Support – Windows, Mac OS, Linux, Solaris
Browser Support – Mozilla Firefox, Internet Explorer, Google Chrome 12.0.712.0 and above, Safari, Opera 11.5 and above, Android, iOS, HtmlUnit 2.9 and above
4.	Selenium Grid:
Selenium Grid is a tool used together with Selenium RC to run tests on different machines against different browsers in parallel. That is, running multiple tests at the same time against different machines running different browsers and operating systems.

Selenium Web Driver is a well designed object oriented API supports many languages such as Java, C#, Python etc. Let’s see what is API and then we move on to know the complete picture of Selenium WebDriver Architecture.


**********************

Selenium Web Driver Architecture
We see Selenium Web Driver Architecture in detail. Architecture of Selenium Web Driver is all about how Selenium works internally. We know Selenium is a browser automation tool which interacts with browser and automate end to end tests of a web application.

WebDriver driver = new FirefoxDriver();

API: 
Application Programming Interface (API) works as an interface between various software components.

Selenium Web Driver API:

Selenium Web driver API helps in communication between languages and browsers. Selenium supports many programming languages such as Java, .net, Python, C#,  PHP etc., and also it supports multiple browsers such as Google Chrome, Firefox, Internet Explorer etc.,
Every browser has different logic of performing actions like loading a page, closing the browser etc.

Selenium Web Driver Framework Architecture Diagram:


 

Selenium Web Driver Architecture
There are four components of Selenium Architecture:
1.	Selenium Client Library/Language Bindings
2.	JSON Wire Protocol over HTTP
3.	Browser Drivers
4.	Real Browsers

1.	Selenium Client Libraries/Language Bindings:
Selenium supports multiple libraries such as Java, .net, Python, C#,  PHP etc. Selenium Developers have developed language bindings to allow Selenium to support multiple languages. 

2.	JSON WIRE PROTOCOL Over HTTP Client:
JSON (JavaScript Object Notation) it is used to transfer data between a client and a server on the web. 
JSON Wire Protocol is a REST API that transfers the information between HTTP servers. Each Browser Driver (such as Firefox Driver, Chrome Driver etc.) has its own HTTP server.
Having all the details in JSON payload session as OS name, JavaScript enabled, TakeScreenShot true, machine name etc shown in below box

JSON payload session
{
  "a": {
    "mobileEmulationEnabled": false,
    "hasTouchScreen": true,
    "platform": "XP",
    "acceptSslCerts": false,
    "goog:chromeOptions": {
      "debuggerAddress": "localhost:3948"
    },
    "acceptInsecureCerts": false,
    "webStorageEnabled": true,
    "browserName": "chrome",
    "takesScreenshot": true,
    "javascriptEnabled": true,
    "setWindowRect": true,
    "unexpectedAlertBehaviour": "ignore",
    "applicationCacheEnabled": false,
    "rotatable": false,
    "networkConnectionEnabled": false,
    "chrome": {
      "chromedriverVersion": "2.44.609538 (b655c5a60b0b544917107a59d4153d4bf78e1b90)",
      "userDataDir": "C:\\Users\\RAMCHE~1\\AppData\\Local\\Temp\\scoped_dir5568_21073"
    },
    "takesHeapSnapshot": true,
    "pageLoadStrategy": "normal",
    "databaseEnabled": false,
    "handlesAlerts": true,
    "version": "72.0.3626.121",
    "browserConnectionEnabled": false,
    "nativeEvents": true,
    "webdriver.remote.sessionid": "acc41048-38d5-4c22-b6f4-9b41ca141727",
    "locationContextEnabled": true,
    "cssSelectorsEnabled": true
  }
}




3.	Browser Drivers:
Each browser contains separate browser driver. Browser drivers communicate with respective browser without revealing the internal logic of browser’s functionality. When a browser driver is received any command then that command will be executed on the respective browser and the response will go back in the form of HTTP response.

4.	Browsers:
Selenium supports multiple browsers such as Firefox, Chrome, IE, Safari etc.,





























Let’s see how Selenium WebDriver works internally

1. Selenium client libraries (say Java)
In real time, you write a code in your UI (say Eclipse IDE) using any one of the supported Selenium client libraries (say Java).
Example:

WebDriver driver = new FirefoxDriver();
driver.get(“https://www.softwaretestingmaterial.com”)

Once you are ready with your script, you will click on Run to execute the program. 
Based on the above statements, Firefox browser will be launched and it will navigate to softwartestingmaterial website.
Here we see what will happen internally after you click on Run till the launch of Firefox browser.

2. JSON Wire Protocol over HTTP
Once you click on Run, every statement in your script will be converted as a URL with the help of JSON Wire Protocol over HTTP. The URL’s will be passed to the Browser Drivers. (In the above code, we took Firefox Driver). Here in our case the client library (java) will convert the statements of the script to JSON format and communicates with the FirefoxDriver. URL looks as shown below.

http://localhost:8080/{"url":"https://www.softwaretestingmaterial.com"}

3. Browser Driver
Every Browser Driver uses a HTTP server to receive HTTP requests.  

4. Browser Driver and Real Browser
Once the URL reaches the Browser Driver, then the Browser Driver will pass that request to the real browser over HTTP. Then the commands in your selenium script will be executed on the browser.
If the request is POST request then there will be an action on browser

**********************


What is Manual testing?
Manual Testing is a type of Software Testing where Testers manually execute test cases without using any automation tools. Manual Testing is the most primitive of all testing types and helps find bugs in the software system.
Any new application must be manually tested before its testing can be automated. Manual Testing requires more effort but is necessary to check automation feasibility.
What is Automation Testing?
Manual Testing is performed by a human sitting in front of a computer carefully executing the test steps.
Automation Testing means using an automation tool to execute your test case suite.
The automation software can also enter test data into the System Under Test, compare expected and actual results and generate detailed test reports. Test Automation demands considerable investments of money and resources.
Manual Testing vs Automation Testing
Manual Testing	Automated Testing
Manual testing requires human intervention for test execution.	Automation Testing is use of tools to execute test cases
Manual testing will require skilled labour, long time & will imply high costs.	Automation Testing saves time, cost and manpower. Once recorded, it's easier to run an automated test suite
Any type of application can be tested manually, certain testing types like ad-hoc and monkey testing are more suited for manual execution.	Automated testing is recommended only for stable systems and is mostly used for Regression Testing

Manual testing can become repetitive and boring.	The boring part of executing same test cases time and again is handled by automation software in Automation Testing.
Type of Software Testing
In general, there are three testing types
•	Functional
•	Non - Functional
•	Maintenance
 
Black Box Testing
•	White Box Testing
•	Unit Testing
•	System Testing
•	Integration Testing
•	Acceptance Testing
What is Unit Testing?
UNIT Testing is defined as a type of software testing where individual units/ components of a software are tested.
Unit Testing of software applications is done during the development (coding) of an application. The objective of Unit Testing is to isolate a section of code and verify its correctness. 
 
What is Integration Testing?
Integration Testing is defined as a type of testing where software modules are integrated logically and tested as a group.
A typical software project consists of multiple software modules, coded by different programmers. Integration Testing focuses on checking data communication amongst these modules.
What is System Testing?
System Testing is the testing of a complete and fully integrated software product. Usually, software is only one element of a larger computer-based system. Ultimately, software is interfaced with other software/hardware systems. System Testing is actually a series of different tests whose sole purpose is to exercise the full computer-based system.
Two Category of Software Testing
•	Black Box Testing
•	White Box Testing

What is Regression Testing?
Regression Testing is defined as a type of software testing to confirm that a recent program or code change has not adversely affected existing features.
Regression Testing is nothing but a full or partial selection of already executed test cases which are re-executed to ensure existing functionalities work fine.
This testing is done to make sure that new code changes should not have side effects on the existing functionalities. It ensures that the old code still works once the new code changes are done.
Regression Testing Tools
If your software undergoes frequent changes, regression testing costs will escalate.
In such cases, Manual execution of test cases increases test execution time as well as costs.
Automation of regression test cases is the smart choice in such cases.  
The extent of automation depends on the number of test cases that remain re-usable for successive regression cycles. 
What is Non-Functional Testing?
Non-functional testing is defined as a type of Software testing to check non-functional aspects (performance, usability, reliability, etc) of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing.
An excellent example of non-functional test would be to check how many people can simultaneously login into a software.
1) Security:
The parameter defines how a system is safeguarded against deliberate and sudden attacks from internal and external sources. This is tested via Security Testing.
2) Reliability:
The extent to which any software system continuously performs the specified functions without failure. This is tested by Reliability Testing
3) Survivability:
The parameter checks that the software system continues to function and recovers itself in case of system failure. This is checked by Recovery Testing
4) Availability:
The parameter determines the degree to which user can depend on the system during its operation. This is checked by Stability Testing.
5) Usability:
The ease with which the user can learn, operate, prepare inputs and outputs through interaction with a system. This is checked by Usability Testing
6) Scalability:
The term refers to the degree in which any software application can expand its processing capacity to meet an increase in demand. This is tested by Scalability Testing
7) Interoperability:
This non-functional parameter checks a software system interfaces with other software systems. This is checked by Interoperability Testing
8) Efficiency:
The extent to which any software system can handles capacity, quantity and response time.
9) Flexibility:
The term refers to the ease with which the application can work in different hardware and software configurations. Like minimum RAM, CPU requirements.
10) Portability:
The flexibility of software to transfer from its current hardware or software environment.
11) Reusability:
It refers to a portion of the software system that can be converted for use in another application.




1.	Usability Testing - Usability Testing mainly focuses on the user's ease to use the application, flexibility in handling controls and ability of the system to meet its objectives


2.	Load Testing - Load Testing is necessary to know that a software solution will perform under real-life loads.


3.	Regression Testing- - Regression Testing involves testing done to make sure none of the changes made over the course of the development process have caused new bugs. It also makes sure no old bugs appear from the addition of new software modules over time.


4.	Recovery Testing - Recovery testing is done to demonstrate a software solution is reliable, trustworthy and can successfully recoup from possible crashes.


5.	Migration Testing - Migration testing is done to ensure that the software can be moved from older system infrastructures to current system infrastructures without any issues.


6.	Functional Testing - Also known as functional completeness testing, Functional Testing involves trying to think of any possible missing functions. Testers might make a list of additional functionalities that a product could have to improve it during functional testing.


7.	Hardware/Software Testing - IBM refers to Hardware/Software testing as "HW/SW Testing". This is when the tester focuses his/her attention on the interactions between the hardware and software during system testing.


**********************


1.	Static wait and
2.	Dynamic wait	

1 .Static wait: Thread sleep wait
Thread.sleep(10000);

2.  Dynamic wait (implicit and explicit wait)	
2.1 Page load time out
driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS);

2.2. Implicit wait
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

2.3 Explicit wait
WebDriverWait webDriverWait11 = new WebDriverWait(driver, 30);
	webDriverWait11.until(ExpectedConditions.elementToBeClickable(driver.findElement(By.id("id")))).click();

2.4polling wait
WebDriverWait wait22= new WebDriverWait(driver, 10);
wait22.pollingEvery(2, TimeUnit.SECONDS);
wait22.until(ExpectedConditions.visibilityOf(driver.findElement(By.id(""))));

2.5. Fluent wait
Wait<WebDriver> wait2 = new FluentWait<WebDriver>(driver).
	withTimeout(30, TimeUnit.SECONDS).
	pollingEvery(2, TimeUnit.SECONDS).
	ignoring(NoSuchElementException.class);
WebElement userName = wait2.until(new Function<WebDriver, WebElement>() {
			@Override
			public WebElement apply(WebDriver driver) {
				return driver.findElement(By.id("id"));
			}
		});
		
		


1 .Static wait: Thread sleep wait
Thread.sleep(10000);
Here irrespective of any condition the page will be wait for 10 seconds even after completion of all actions.

2.  Dynamic wait (implicit and explicit wait)	
2.1 Page load time out
driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS);

This wait to waiting to load the complete page for 10 seconds before 10 second if page loads then next actions will be continued else after 10 sec throws TimeOutException 

2.2. Implicit wait
driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

Implicit wait- Dynamic in nature
-It can be changed anywhere anytime in our code ie we can override and the latest value applied
Implicit wait- is always applied globally which directly applied to driver where it is available for all web element on a page.

2.3 Explicit wait
WebDriverWait webDriverWait11 = new WebDriverWait(driver, 30);
	webDriverWait11.until(ExpectedConditions.elementToBeClickable(driver.findElement(By.id("id")))).click();

Explicit wait:
1.	Explicit wait- also dynamic nature
2.	No explicit keyword or method
3.	Available with WebDriverWait class 
4.	Applied for specific element with some specific expected condition
5.	Never use implicit and explicit wait together :  Because selenium WD will wait for the element first  because of IMLICIT wait and then EXPLICIT wait both will be applied hence total synchronization wait will be increased for each element. 

Do we need to have implicit and explicit wait together ?
No, It’s not at all recommended to use it both together, because when we apply Implicit wait- this will always applied globally which directly applied to a driver where it is available for all web element with respective to driver.
So when we apply both together then first implicitly wait applied to element and again explicit wait applied to same element .

Can we override Imlicit wait ?
Yes, the latest last applied Implicit wait value will be considered.
 
http://www.way2automation.com/webdriver-implicit-vs-explicit-vs-fluent-wait.php
WebDriver Wait, Implicit Wait, Explicit Wait and Fluent Wait
BY RAMAN  29/12/2014

680Comments
Selenium WebDriver: - Synchronizing a Test Using Waits
One of the Important Factor in test automation for a complex web application is to ensure that the flow of the test cases should be in synchronization with the application under test (AUT).
When tests are run, the application may not always respond with the same speed. For example, it might take a few seconds for a progress bar to reach 100 percent, a status message to appear, a button to become enabled, and a window or pop-up message to open. We can handle these anticipated timing problems by synchronizing our test to ensure that Selenium WebDriver waits until our application is ready before performing a certain action. There are several options that we can use to synchronize our test. 
 
Synchronizing a test with an implicit wait
When an implicit wait is implemented it tells WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0.Once set the implicit wait is set for the life of the WebDriver object's instance. However, an implicit wait may slow down our tests when an application responds normally, as it will wait for each element to appear in the DOM and increase the overall execution time.
driver.manage().timeouts().implicitlyWait(Time period, TimeUnit.SECONDS);
Time period: Here time value is given as input. How many seconds the driver has to wait.
TimeUnit.SECONDS: Time period is measured as second here. You can use other time unit like day, microseconds, nanoseconds etc.
Example: -
Synchronizing a test with FluentWait
When a FluentWait instance is implemented it defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition. Furthermore, the user may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementExceptions when searching for an element on the page.
@Test
public void test(){
Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)
       .withTimeout(30, SECONDS)
       .pollingEvery(5, SECONDS)
       .ignoring(NoSuchElementException.class);
 
   WebElement foo = wait.until(new Function<WebDriver, WebElement>() {
     public WebElement apply(WebDriver driver) {
       return driver.findElement(By.id("Element"));
     }
   });}
 
Above code snippet will Wait 30 seconds for an element to be present on the page and check for its presence once every 5 seconds.
 
Synchronizing a test with an Explicit wait
 
When an Explicit Wait is implemented it provides a better control when compared with an implicit wait. Unlike an implicit wait, we can write custom code or conditions for wait before proceeding further in the code. An explicit wait can only be implemented in cases where synchronization is needed and the rest of the script is working fine. The Selenium WebDriver provides WebDriverWaitand ExpectedCondition classes for implementing an explicit wait. The ExpectedCondition class provides a set of predefined conditions to wait before proceeding further in the code.
The following are some common conditions that we frequently come across when automating web browsers supported by the ExpectedCondition class:- 
    Predefined condition	       Selenium method
An element is visible and enabled 	elementToBeClickable(By locator)
An element is selected 	elementToBeSelected(WebElement element)
Presence of an element 	presenceOfElementLocated(By locator)
Specific text present in an element	textToBePresentInElement(By locator,
java.lang.String text)
 
How it Works:-
We can create a wait for a set of common conditions using the ExpectedCondition class. First, we need to create an instance of the WebDriverWait class by passing the driver instance and timeoutfor a wait as follows:
 
WebDriverWait wait = new WebDriverWait(driver, 10);
Next, ExpectedCondition is passed to the wait.until() method as follows:
wait.until(ExpectedConditions.titleContains("selenium"));
 
Note: - The WebDriverWait object will call the ExpectedCondition class object every 500 milliseconds until it returns successfully.
 
Example: -
 
@Test
public void test(){
WebDriverWait wait = new WebDriverWait(driver, 10);
wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("Element")));    driver.findElement(By.id("Element")).clear();    
driver.findElement(By.id("Element")).sendKeys("India");
driver.findElement(By.id("Element")).click();
}
 
Custom-expected condition: WebDriver provide us to create custom wait condition.
 
Example: 
 
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
 
public class testwait {
 
       private WebDriver driver;
       private String baseUrl;
 
       @BeforeMethod
       public void setUp() throws Exception {
             driver = new FirefoxDriver();
             baseUrl = "http://www.flipkart.com";
 
       }
 
       @Test
       public void testUntitled() throws Exception {
             driver.get(baseUrl);
 
             // custom explicit wait for search field
             new WebDriverWait(driver, 10)
                           .until(new ExpectedCondition<WebElement>() {
                                 @Override
                                 public WebElement apply(WebDriver d) {
                                        return d.findElement(By.id("fk-top-search-box"));
                                 }
                           });
 
             driver.findElement(By.id("fk-top-search-box")).sendKeys("Laptop");
             driver.findElement(
                           By.xpath(".//*[@id='fk-header-search-form']/div/div/div[2]/input[1]"))
                           .click();
 
       }
 
       @AfterMethod
       public void tearDown() throws Exception {
             driver.quit();
       }
}


**********************

What are challenges faced during selenium automation/ disadvantages of selenium/ what are all we cannot automate?

1. Images or text overlapping issue cannot verify.
2. No facility to capture capatch and Bar code.
3. Does not support non web and mobile application.
4. Open source - so there is no direct support.
5. Bitmap comparison (BMP) does not support.
6. Report: No reporting API/capabilities available need to use 3rd party tools like TestNG and Extent reporting
7. Need to learn native programming language Java, python, .net, PHP etc
8. Difficult to identify dynamic object (dynamic Xpath).
9. Working with frame (ex: in ecommerce more than 10 frames jumping one frame to other or coming back it's difficult).
//10. JavaScript sandbox, flash and HTML-5 are all preset problems.
11. Dealing with pop-up never know what kind of pop-up will be (java script, wind pop-up, model pop-up or browser pop-up)
12. *** Time out resulting from synchronization problem: 
When to use implicit wait, explicit wait sometime explicit wait also does not works need to use JavaScriptExecutor also need to check element is present, is enabled and is selected we will get StaleElementException, ElementNotFoudException, ElementNotVisibleException where
We must know how to use implicit, explicit, fluent wait then JavaScriptExecutor is the solution where we should never use Thread.sleep().
13. Cross browser testing issue, 500 TC execting on chrome then need to exected all on other browser.
14. Handling Ajax Components: Asynchronous call 
Example: on home page 2 dropdown
Country: USA
State: California
On changing country INDIA then a valid wait need to reset the state dropdown and Indian state sometime the USA state only displayed.

What are disadvantages of selenium/ what are all we cannot automate?

1. Images or text overlapping issue cannot verified.
2. No facility to capture capatch and Bar code.
3. Does not support non web application.
4. Selenium will support mobile application.
5. Report: No direct reporting API/capabilities available need to use 3rd party tools like TestNG and Extent reporting

**********************

XPath Contains, Sibling, Ancestor, AND OR, Parent, Start with, Axes in Selenium Webdriver


If a simple XPath is not able to find a complicated web element for our test script, we need to use the functions from XPath 1.0 library. 
[http://demo.guru99.com/test/guru99home/]

1.	Contains
2.	Sibling
3.	Ancestor
4.	And & OR
5.	Parent
6.	Starts-with and ends-with
7.	XPath Axes
8.	Text()

•	Contains
By using 'contains' function in XPath, we can find/extract all the web elements/locators which matches a particular text value.
Ex. Here we are searching an anchor .contains text as 'SAP M'.

// a[contains(text(),'SAP M')]
// input[contains(@id,'test-12')]


[Finding the locator based on the given text]
•	Sibling
Using sibling keyword, we can fetch a web element which is related to some other element.
Example: Here on the basis of sibling element of 'a' we are finding 'h4'
"//div[@class='canvas- graph']//a[@href='/accounting.html'][i[@class='icon-usd']]/following-sibling::h4"
[Finding all the locators which are related to ]

•	Ancestor: To find an element on the basis of the parent element we can use ancestor
 Attribute of XPath.
//div[.//a[text()='SELENIUM']]/ancestor::div[@class='rt-grid-2 rt-omega']/following-sibling::div


•	Using AND and OR
By using AND and OR you can put 2 conditions in our XPath expression.
•	In case of AND both 2 conditions should be true then only it finds the element.
•	In case of OR any one of the 2 conditions should be true then only it finds the element.
Here our XPath query will be like
Xpath=//*[@type='submit' OR @name='btnReset']
Xpath=//input[@type='submit' and @name='btnLogin']

•	Parent
By Using Parent, you can find the parent node of the current node in the web page.
Here our XPath query will be like
Xpath=//*[@id='rt-feature']//parent::div


•	Starts-with
Using Starts-with function, you can find the element whose attribute dynamically changes on refresh or other operations like click, submit, etc.
Here our XPath query will be like
Xpath=//label[starts-with(@id,'message')]
[Where the 'message' should be present in both of the id]

•	Xpath axes
By using XPath axes, you can find the dynamic and very complex elements on a web page. XPath axes contain several methods to find an element. Here, will discuss a few methods.
1.	following: This function will return the immediate element of the particular component.
Here our XPath query will be like
Xpath=//*[@type='text']//following::input


2.	Preceding: This function will return the preceding element of the particular element.
Here our XPath query will be like
Xpath= //*[@type='submit']//preceding::input

3.	 Descendant: This function will return the descendant element of the particular element.
Here our XPath query will be like
Xpath= //*[@id='rt-feature']//descendant::a


**********************
UNIT TESTING 
Unit testing is a type of software testing where individual units or components of software are tested. 
The purpose is to validate that each unit of the software code performs as expected. Unit Testing is done during the development (coding phase) of an application by the developers. A unit may be an individual function, method, procedure, module, or object.
In SDLC, STLC, V Model, Unit testing is first level of testing done before integration testing. 
Unit testing is a White Box testing technique that is usually performed by the developer.
Unit Testing Advantage
•	Developers looking to learn what functionality is provided by a unit and how to use it can look at the unit tests to gain a basic understanding of the unit API.
•	Unit testing allows the programmer to re factor code at a later date, and make sure the module still works correctly (i.e. Regression testing).
•	Due to the modular nature of the unit testing, we can test parts of the project without waiting for others to be completed.

UNIT TESTING is defined as a type of software testing where individual units or components of software are tested.
As you can see, there can be a lot involved in unit testing. It can be complex or rather simple depending on the application being tested and the testing strategies, tools and philosophies used. Unit testing is always necessary on some level. That is a certainty.

Unit Testing Tools
There are several automated tools available to assist with unit testing. We will provide a few examples below:
1.	Junit: Junit is a free to use testing tool used for Java programming language.  It provides assertions to identify test method. This tool test data first and then inserted in the piece of code.
2.	NUnit:  NUnit is widely used unit-testing framework use for all .net languages.  It is an open source tool which allows writing scripts manually. It supports data-driven tests which can run in parallel.
3.	JMockit:  JMockit is open source Unit testing tool.  It is a code coverage tool with line and path metrics. It allows mocking API with recording and verification syntax. This tool offers Line coverage, Path Coverage, and Data Coverage.
4.	EMMA:  EMMA is an open-source toolkit for analyzing and reporting code written in Java language. Emma support coverage types like method, line, basic block. It is Java-based so it is without external library dependencies and can access the source code.
5.	PHPUnit: PHPUnit is a unit testing tool for PHP programmer. It takes small portions of code which is called units and test each of them separately.  The tool also allows developers to use pre-define assertion methods to assert that a system behave in a certain manner. 



INTEGRATION TESTING 
Integration testing is defined as a type of testing where software modules are integrated logically and tested as a group. A typical software project consists of multiple software modules, coded by different programmers. The purpose of this level of testing is to expose defects in the interaction between these software modules when they are integrated
 Integration Testing focuses on checking data communication amongst these modules.
Why need Integration testing: 
•	Al modules are designed by an individual software developer whose understanding and programming logic may differ from other programmers. Integration Testing becomes necessary to verify the software modules work after integrating together all modules.
•	During development, there are wide chances of change in requirements by the clients. These new requirements may not be unit tested and hence system integration Testing becomes necessary.
•	Interfaces of the software modules with the database could be erroneous
•	External Hardware interfaces, if any, could be erroneous
Approaches, Strategies, Methodologies of Integration Testing
Software Engineering defines variety of strategies to execute Integration testing, viz.
•	 Big Bang Approach :
•	 Incremental Approach: which is further divided into the following
o	 Top Down Approach
o	 Bottom Up Approach
o	 Sandwich Approach - Combination of Top Down and Bottom Up
1.	Big Bang Approach:
Here all component are integrated together at once and then tested.
2.	Incremental Approach
In this approach, testing is done by joining two or more modules that are logically related
Incremental Approach, in turn, is carried out by two different Methods:
•	Bottom Up
•	Top Down

Bottom-up Integration
In the bottom-up strategy, each module at lower levels is tested with higher modules until all modules are tested.

 
Top-down Integration:
In Top to down approach, testing takes place from top to down following the control flow of the software system.
 
How to do Integration Testing
The Integration test procedure irrespective of the Software testing strategies (discussed above):
1.	Prepare the Integration Tests Plan
2.	Design the Test Scenarios, Cases, and Scripts.
3.	Executing the test Cases followed by reporting the defects.
4.	Tracking & re-testing the defects.
5.	Steps 3 and 4 are repeated until the completion of Integration is successful.


SYSTEM TESTING 
System testing is a level of testing that validates the complete and fully integrated software product. 
The purpose of a system test is to evaluate the end-to-end system specifications. System Testing is actually a series of different tests whose sole purpose is to exercise the full computer-based system.
What do you verify in System Testing
•	Testing the fully integrated applications including external peripherals in order to check how components interact with one another and with the system as a whole. This is also called End to End testing scenario.
•	Verify thorough testing of every input in the application to check for desired outputs.
•	Testing of the user's experience with the application. 
Types of System Testing
1.	Usability Testing- mainly focuses on the user's ease to use the application, flexibility in handling controls and ability of the system to meet its objectives
2.	 Load Testing- is necessary to know that a software solution will perform under real-life loads.
3.	Regression Testing- involves testing done to make sure none of the changes made over the course of the development process have caused new bugs. It also makes sure no old bugs appear from the addition of new software modules over time.
4.	Recovery testing- is done to demonstrate a software solution is reliable, trustworthy and can successfully recoup from possible crashes.
5.	Migration testing- is done to ensure that the software can be moved from older system infrastructures to current system infrastructures without any issues.
6.	Functional Testing - Also known as functional completeness testing, Functional Testing involves trying to think of any possible missing functions. Testers might make a list of additional functionalities that a product could have to improve it during functional testing.
7.	Hardware/Software Testing - This is where the tester focuses his/her attention on the interactions between the hardware and software during system testing.


Sanity Testing Vs Smoke Testing
Smoke Testing
Smoke Testing is a kind of Software Testing performed after software build to ascertain that the critical functionalities of the program are working fine. It is executed "before" any detailed functional or regression tests are executed on the software build. The purpose is to reject a badly broken application so that the QA team does not waste time installing and testing the software application.
Smoke Testing, the test cases chose to cover the most important functionality or component of the system. 
The objective is not to perform exhaustive testing, but to verify that the critical functionalities of the system are working fine.
For Example: Verify that the application launches successfully, Check that the GUI is responsive, application logged in successfully etc.
Sanity Testing
Sanity testing is a kind of Software Testing performed after receiving a software build, with minor changes in code, or functionality, to ascertain that the bugs have been fixed and no further issues are introduced due to these changes. The goal is to determine that the proposed functionality works roughly as expected. If sanity test fails, the build is rejected to save the time and costs involved in a more rigorous testing.
The objective is "not" to verify thoroughly the new functionality but to determine that the developer has applied some rationality (sanity) while producing the software 
For Example: calculator gives the result of 2 + 2 =5! Then, there is no point testing the advanced functionalities like sin 30 + cos 50.





Smoke Testing Vs Sanity Testing - Key Differences
Smoke Testing	Sanity Testing
Smoke Testing is performed to ascertain that the critical functionalities of the program is working fine	Sanity Testing is done to check the new functionality/bugs have been fixed roughly not rigorous functional testing 
The objective of this testing is to verify the "stability" of the system in order to proceed with more rigorous testing	The objective of the testing is to verify the "rationality" of the system in order to proceed with more rigorous testing
This testing is performed by the developers or testers	Sanity testing is usually performed by testers
Smoke testing is usually documented or scripted	Sanity testing is usually not documented and is unscripted
Smoke testing is a subset of Acceptance testing	Sanity testing is a subset of Regression Testing

Smoke testing exercises the entire system from end to end	Sanity testing exercises only the particular component of the entire system
Smoke testing is like General Health Check Up	Sanity Testing is like specialized health check up

Points to note:
•	Both sanity tests and smoke tests are ways to avoid wasting time and effort by quickly determining whether an application is too flawed to merit any rigorous testing. 
•	Sanity Testing is also called tester acceptance testing.
•	Smoke testing performed on a particular build is also known as a build verification test.
•	One of the best industry practices is to conduct a Daily build and smoke test in software projects.
•	Both smoke and sanity tests can be executed manually or using an automation tool.  When automated tools are used, the tests are often initiated by the same process that generates the build itself.
•	As per the needs of testing, you may have to execute both Sanity and Smoke Tests in the software build. In such cases, you will first execute Smoke tests and then go ahead with Sanity Testing. In industry, test cases for Sanity Testing are commonly combined with that for smoke tests, to speed up test execution. Hence, it's a common that the terms are often confused and used interchangeably

REGRESSION TESTING 
Regression Testing is defined as a type of software testing to confirm that a recent program or code change has not adversely affected existing features.
Regression Testing is nothing but a full or partial selection of already executed test cases which are re-executed to ensure existing functionalities work fine.
This testing is done to make sure that new code changes should not have side effects on the existing functionalities. It ensures that the old code still works once the latest code changes are done.
Why do need of Regression Testing
Regression Testing is required when there is a
•	Change in requirements and code is modified according to the requirement
•	New feature is added to the software
•	Defect fixing
•	Performance issue fix 
Regression Testing Tools
•	Selenium: This is an open source tool used for automating web applications. Selenium can be used for browser-based regression testing.
•	Quick Test Professional (QTP): HP Quick Test Professional is automated software designed to automate functional and regression test cases. It uses VBScript language for automation. It is a Data-driven, Keyword based tool. 
•	Rational Functional Tester (RFT): IBM's rational functional tester is a Java tool used to automate the test cases of software applications. This is primarily used for automating regression test cases and it also integrates with Rational Test Manager. 
Difference between Re-Testing and Regression Testing:
Retesting means testing the functionality or bug again to ensure the code is fixed. If it is not fixed, Defect needs to be re-opened. If fixed, Defect is closed.
Regression testing means testing your software application when it undergoes a code change to ensure that the new code has not affected other parts of the software.

Non-Functional Testing
Non-functional testing is defined as a type of Software testing to check non-functional aspects (performance, usability, reliability, etc) of a software application. It is designed to test the readiness of a system as per nonfunctional parameters which are never addressed by functional testing.
An excellent example of non-functional test would be to check how many people can simultaneously login into software.
Objectives of Non-functional testing
•	Non-functional testing should increase usability, efficiency, maintainability, and portability of the product.
•	Helps to reduce production risk and cost associated with non-functional aspects of the product.
•	Optimize the way product is installed, setup, executes, managed and monitored.
•	Collect and produce measurements, and metrics for internal research and development.
•	Improve and enhance knowledge of the product behavior and technologies in use.
Non-functional testing Parameters
 
1) Security:
The parameter defines how a system is safeguarded against deliberate and sudden attacks from internal and external sources. This is tested via Security Testing.
2) Reliability:
The extent to which any software system continuously performs the specified functions without failure. This is tested by Reliability Testing
3) Survivability:
The parameter checks that the software system continues to function and recovers itself in case of system failure. This is checked by Recovery Testing
4) Availability:
The parameter determines the degree to which user can depend on the system during its operation. This is checked by Stability Testing.
5) Usability:
The ease with which the user can learn, operate, prepare inputs and outputs through interaction with a system. This is checked by Usability Testing
6) Scalability:
The term refers to the degree in which any software application can expand its processing capacity to meet an increase in demand. This is tested by Scalability Testing
7) Interoperability:
This non-functional parameter checks a software system interfaces with other software systems. This is checked by Interoperability Testing
8) Efficiency:
The extent to which any software system can handles capacity, quantity and response time.
9) Flexibility:
The term refers to the ease with which the application can work in different hardware and software configurations. Like minimum RAM, CPU requirements.
10) Portability:
The flexibility of software to transfer from its current hardware or software environment.
11) Reusability:
It refers to a portion of the software system that can be converted for use in another application.


Type of Software Testing
In general, there are three testing types
•	Functional
•	Non - Functional
•	Maintenance
 
**********************

============
Dynamic web table Xpath handling: 
============

*//table/tbody/tr[2]/td[1]
*//table/tbody/tr[3]/td[1]
*//table/tbody/tr[4]/td[1]
*//table/tbody/tr[5]/td[1]

============
Method 1: Iteraing dynamic table loop and searching (ie name ram in a row) and clicking on it.
============
String beforXpath="*//table/tbody/tr[";
String afterXpath="]/td[1]";
	for(int i=2;i<=5;i++){
		String xpath=driver.findElement(By.xpath(beforXpath+i+afterXpath)).getText();
			if(xpath.conatains("ram")){
				driver.findElement(By.xpath(beforXpath+i+afterXpath)).click();
			}
	}
	
============
Method 1:  searching xpath using //parent:: ,/child::, //preceding, //preceding-sibling::, //following, //following-sibling::
 clicking on it.
============
//*[contains(text(),'friend')]//preceding-sibling::td
//*[contains(text(),'friend')]//following-sibling::td
//*[contains(text(),'5/7/2019 12:00:00 AM']/parent::td//pareceding-sibling::td//input[@name='contact_id']

============
following & sibling : works only when all element comes under same parent.
============


============
parent:: [root node element for the pointed element]
============
//a[@href="/features"]//parent::*  } gets the parents of //a[@href="/features"]
//a[@href="/features"]/parent::*/following-sibling::li[2]


============
child:: next parent
============
//div[@id='reg_form_box']/child::*  } will get all childs
//div[@class='header__container']/child::nav
//div[@class='header__container']/child::nav//ul//li//a[@href='/about-actitime']
where all "nav,ul,li and a" are childs of div and point to end Xpath a[@href='/about-actitime']
//div[@class='header__container']/child::nav//ul//child::li[1]


==========
following-sibling::  farward direction
==========
//a[@href="/features"]/parent::*/following-sibling::li  	} all sibling
//a[@href="/features"]/parent::*/following-sibling::li[2]	} poing 2nd link
//a[@href="/features"]/parent::*/following-sibling::li[2]/a } poing 2nd link getting inside
	
bhavya@rupeelog.com

=========
preceding-sibling::  backward direction
=========
//a[@href='/testimonials' and @class='main-menu__link']/parent::*//preceding-sibling::li[2]/a

=========

=========
//div[@id='reg_form_box']/child::* 
//div[@id='reg_form_box']/child::div[1]/descendant::div[1]//input[@name='firstname']
OR equal to about like relative xpath complete child & descendant 
//div[@id='reg_form_box']//child::div[1]//descendant::div[1]/descendant::div[1]/descendant::div[1]/descendant::div[1]/descendant::div[1]
//div[@id='reg_form_box']//child::div[1]//descendant::div[1]//input[@name='lastname']


============================================================================================
//parent:: ,/child::, //preceding, //preceding-sibling::, //following, //following-sibling:: and //descendant::
following & sibling : works only when all element comes under same parent.
============================================================================================
1. //parent:: Root node to given element
2. //child:: Next/immediate child element of parent
3. //preceding:: Before/backward element of parent
4. //preceding-sibling:: Before/backward element of parents sibling
5. //following:: Next/forward element of parent 
6. //following-sibling:: Next/forward element of parent sibling
7. //descendant:: all child elements of parent
=============
1. //parent:: 
=============
//a[@href="/features"]//parent::* 		 } gets the parents of //a[@href="/features"]
//a[@class='header__logo']/parent::div
//a[@href="/features"]/parent::*/following-sibling::li[2]

2. //child::
=============
//div[@id='reg_form_box']/child::*  } will get all childs
//div[@class='header__container']/child::nav
//div[@class='header__container']/child::nav//ul//li//a[@href='/about-actitime']
where all "nav,ul,li and a" are childs of div and point to end Xpath a[@href='/about-actitime']
//div[@class='header__container']/child::nav//ul//child::li[1]

3. //preceding::
=============
//a[@href='/testimonials' and @class='main-menu__link']/parent::*//preceding::li[2]/a

4. //preceding-sibling::
=============
//a[@href='/testimonials' and @class='main-menu__link']/parent::*//preceding-sibling::li[2]/a

5. //following::
=============
//a[@href="/features"]/parent::*/following::li 

6. //following-sibling::
=============
//a[@href="/features"]/parent::*/following-sibling::li  	} all sibling
//a[@href="/features"]/parent::*/following-sibling::li[2]	} poing 2nd link
//a[@href="/features"]/parent::*/following-sibling::li[2]/a } poing 2nd link getting inside

7. //descendant::
===========
//div[@id='reg_form_box']/child::* 
//div[@id='reg_form_box']/child::div[1]/descendant::div[1]//input[@name='firstname']
OR equal to about like relative xpath complete child & descendant 
//div[@id='reg_form_box']//child::div[1]//descendant::div[1]/descendant::div[1]/descendant::div[1]/descendant::div[1]/descendant::div[1]
//div[@id='reg_form_box']//child::div[1]//descendant::div[1]//input[@name='lastname']

Starts-with: 
===========
To find the element whose attribute dynamically changes on refresh or other operations like click, submit, etc.
 Xpath=//label[starts-with(@id,'message')]
**********************

assertEquals is better because it gives the unit test framework more information about what you're actually interested in. That allows it to provide better error information when the test fails.
Suppose for example you have : 
String a = "Hello";
String b = "Hi";

Then the test failures might look something like:
// From assertEquals(a, b)
Error: Expected "Hi"; was "Hello"

// From assertTrue:
Error: Expected true; was false

Which of those do you think gives you more information, bearing in mind that the values would probably be the result of reasonably complex computations?
(These are made up error messages as I don't have testng installed, but they're the kind of thing unit test frameworks give.)
•	Assert.assertEquals(actual, expected);
Asserts that two arrays contain the same elements in the same order. If they do not, an AssertionError is thrown. 
Parameters: 
actual the actual value 
expected the expected value
•	Assert.assertTrue(condition);
Asserts that a condition is true. If it isn't, an AssertionError is thrown. 
Parameters: 
condition the condition to evaluate


**********************

Why are you looking for a job change?

You should give reasons in such way that interviewer is sure of your stay in the company of longer run. Use the below hints
1.	I am looking for a new challenge to work on new technologies and being an expert in the primary skills.
2.	To restructure my career and for better opportunities and role where money comes second
3.	I feel that I am ready for next stage where to have a long term career and growth with new technologies, ready to accept the challenging environment, in my current organization; we are a small team of 12 people. I have had a great experience and gained important skills like resource management and client servicing. Now I am eager and looking forward to work in larger team and with industry leaders I feel that I am ready to take up more responsibility.
Financial growth
 I have worked with my current employer for the last 3.5 years where I have gained and grown well. I am grateful for my experience as I have in-depth industry knowledge.
 I am keen to stay on the path of progress. I am excited to interact and work closely with teams and the leaders of our industry who are like your organization.
I want to start learning immediately and build my skills, as well as help your organization grow like I helped my current company grow.

**********************

SELENIUM MANAGER

1.	Introduce yourself – Brief name and overall experience and roles & responsibilities and major skill set. 
2.	Explain about your project?- Project title, domain , client, roles & responsibilities in project and different components  
3.	 What are responsibilities in project? – where you involved in your project, your contribution and your role.
4.	What are challenges faced and resolved in your project? Need to explain 5 to 8 chllanges
5.	 Wt team size ?- 10 to 12
6.	Tools and technologies: selenium, java, TestNG, maven, jenking, APACH POI
7.	Where you applied oops concept ? explain Oops and how do you used in your project 
8.	What framework used ?
9.	 SQL query ? need to prepare DML, DDL, Joins and CURD and basic SQL ? query to find highest salary of emp ?
10.	Write TC to capture failed test cases ?
11.	How to create bug reports in Jira ?- test cycle of bug create , new, progress, close and  done
12.	Expalain testing process in your company?
13.	Who assign work to you and how do receive ?
14.	What appreciation you achieved in your company ?
15.	Explain day to day activity in company ? from standup meeting to end reporting report and mail
16.	Suppose 200 TC are need to test but only 2 days left to test, what type of testing you prefer.- need logical thinking and 
17.	 You found defect and sent to developer but development team rejected what you do?-
18.	Explain project framework architecture ?  
19.	Explain the flow of agile process ?

**********************
Slenium ToDo

1.	How will execute only failed test case? (Listeners)D
2.	Extent report needs to go. D
3.	How will extract only duplicate value pair from HashMap for.
4.	How to extract unique values in Array (using set collection framework).
5.	Agile retrospective meeting.
6.	How will you get the only duplicate values from dropdown (using select of getOption())

1.	How you used Encapsulation in your project? –Utility predefined classes are Encapsulation in the used to other classes.
2.	How to use Abstract classes.

1.	JSON parsing in API automation.
2.	Dynamic data fetching from UI table in Selenium
3.	Dynamic Xpath for dynamic text changing for the element.
4.	 Overriding example
5.	 How do get data element value from response object of JSON Array.
6.	Ancestors and sibling in selenium.
7.	 


1.	What JDK-JRE-JVM?
2.	Is JVM platform independent? - No JVM platform dependent and java is platform independent.
3.	How do run script from Jenkins? Pipelining 
4.	Difference between selenium standalone server and selenium WebDriver?
5.	How do you read huge test data? – Excel sheet and properties file need to check which one more preferable.
6.	 Maven structure and its advantages?
7.	TestNG structure and its advantages?
8.	How do you used Abstract class i.e. oops feature in your project?
9.	Explain POM and Pagefactory.initElement(driver,Page.class);?
10.	What is WebElement?
11.	How do you download file in selenium? Without sendKeys();?
12.	Need to know about running script on Firefox browser? need to set ….?
13.	Explain selenium different version in serial way? (IDE, selenium 2-RC, selenium  3-WebDriver and Grid)
14.	Need to read perfectly concept of method overloading and method overriding.

1.	How to pass text/element/locater value dynamically in Xpath?
2.	Collections need to READ proper way HashTable?
3.	How do you used Method overloading and method overriding in your project?
4.	How to fetch dynamic data from table in selenium UI?
5.	Java program printing num in square, triangle etc need to prepare?
6.	

1.	Difference between RestAssured baseUIR and RestAssured basePath
2.	JSONPath need to note completely with respect to Response object.
3.	Again revisit Collections all classes and interface and differences
4.	HTTP methods other than get put post and delete like Patch and all.
5.	

Diff between verification and validation
Diff between  severity and priority



**********************
